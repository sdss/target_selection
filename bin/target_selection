#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# @Author: José Sánchez-Gallego (gallegoj@uw.edu)
# @Date: 2020-02-27
# @Filename: target_selection
# @License: BSD 3-clause (http://www.opensource.org/licenses/BSD-3-Clause)

import logging

import click
import peewee

from sdssdb.peewee.sdss5db import catalogdb, targetdb

from target_selection import log
from target_selection.cartons import BaseCarton


catalog_model = catalogdb.GaiaDR2Source
catalogid = catalog_model._meta.primary_key


def connect(profile=None, dbname=None, user=None, host=None, port=None):
    """Connects the database."""

    if profile:
        targetdb.database.set_profile(profile)

    if dbname or user or host or port:
        targetdb.database.connect(dbname=dbname, user=user, host=host, port=port)

    return targetdb.database.connected


def _create_program_metadata(carton):

    survey = None
    category = None

    # Create program and associated values.
    if carton.survey:
        survey, created = targetdb.Survey.get_or_create(label=carton.targeting_version)
        if created:
            log.debug(f'({carton.name}): created survey {carton.survey!r}')

    if carton.category:
        category, created = targetdb.Category.get_or_create(label=carton.category)
        if created:
            log.debug(f'({carton.name}): created category {carton.category!r}')

    __, created = targetdb.Program.get_or_create(label=carton.name,
                                                 category=category,
                                                 survey=survey)
    if created:
        log.debug(f'({carton.name}): created program {carton.name!r}')


def load_data(carton, results_model):
    """Loads data from the temporary table into targetdb."""

    results_pk = results_model._meta.primary_key

    n_targets = results_model.select().where(results_model.selected == True).count()  # noqa
    if n_targets == 0:
        raise ValueError(f'({carton.name}): no targets found in intermediate table.')

    # Convert magnitude_X in the temporary table into magnitude.X in targetdb.
    results_magnitude_fields = []
    magnitude_fields = []
    for field_name in results_model._meta.fields:
        if 'magnitude_' in field_name:
            band = field_name.split('_')[1]
            magnitude_fields.append(targetdb.Magnitude._meta.fields[band])
            results_magnitude_fields.append(results_model._meta.fields[field_name])

    if len(results_magnitude_fields) > 0:
        log.debug(f'({carton.name}): inserting magnitudes to targetdb.magnitude.')
        magnitude_query = (results_model
                           .select(*results_magnitude_fields)
                           .where(results_model.selected == True)  # noqa
                           .order_by(results_pk))
        cursor = targetdb.Magnitude.insert_from(magnitude_query, magnitude_fields).execute()
        magnitude_pks = list(zip(*cursor))[0]
    else:
        magnitude_pks = None

    # Select the coordinate columns. If they exist in the results table use those,
    # otherwise use the one in the catalog model.
    target_fields = [targetdb.Target.ra, targetdb.Target.dec,
                     targetdb.Target.pmra, targetdb.Target.pmdec, targetdb.Target.epoch]
    select_fields = []
    for target_field in target_fields:
        name = target_field.name
        if name in results_model._meta.fields:
            select_fields.append(results_model._meta.fields[name])
        else:
            select_fields.append(catalog_model._meta.fields[name])

    # Add the target.catalogid value to link with catalog.catalogid.
    target_fields.append(targetdb.Target.catalogid)
    select_fields.append(results_pk)

    # Build the query and get the results as tuples.
    target_query = (results_model
                    .select(*select_fields)
                    .join(catalog_model, on=(results_pk == catalogid))
                    .where(results_model.selected == True)  # noqa
                    .order_by(results_pk))

    target_data = target_query.tuples()

    # Unzip and rezip the tuples adding the magnitude_pks.
    if magnitude_pks:
        target_fields.append(targetdb.Target.magnitude_pk)
        target_data = zip(*zip(*target_data), magnitude_pks)

    # Insert the data and grab the resulting pks.
    log.debug(f'({carton.name}): inserting data to targetdb.target.')
    cursor = targetdb.Target.insert_many(target_data, target_fields).execute()
    target_pks = list(zip(*cursor))[0]

    # Add the new targets to the program_to_target relational table.
    program_pks = [targetdb.Program.get(label=carton.name).pk] * len(target_pks)

    # Create a column for the version_pk.
    version_pks = [targetdb.Version.get(label=carton.targeting_version).pk] * len(target_pks)

    log.debug(f'({carton.name}): inserting data to targetdb.program_to_target.')
    targetdb.ProgramToTarget.insert_many(zip(target_pks, program_pks, version_pks),
                                         [targetdb.ProgramToTarget.target_pk,
                                          targetdb.ProgramToTarget.program_pk,
                                          targetdb.ProgramToTarget.version_pk]).execute()


def process_carton(carton, keep=False, overwrite=False, no_load=False,
                   skip_query=False, tile=None, write_table=False):
    """Processes the target selection for a carton."""

    log.info(f'({carton.name}): running target selection for carton {carton.name!r}.')

    # Check if data has been loaded for this carton and targeting version
    has_targets = (targetdb.Target
                   .select()
                   .join(targetdb.ProgramToTarget)
                   .join(targetdb.Program)
                   .where(targetdb.Program.label == carton.name)
                   .switch(targetdb.ProgramToTarget)
                   .join(targetdb.Version)
                   .where(targetdb.Version.label == carton.targeting_version)
                   .first())

    if has_targets:
        raise ValueError(f'({carton.name}): found existing targets for carton '
                         f'{carton.name!r} with version {carton.targeting_version!r}.')

    _create_program_metadata(carton)

    if overwrite:
        carton.drop_table()

    if not skip_query:
        results_model = carton.run(tile=tile)
    else:
        log.debug(f'({carton.name}): skipping query.')
        results_model = carton.get_model_from_query()

    if write_table:
        carton.write_table()

    if no_load:
        log.debug(f'({carton.name}): not loading data into targetdb.target.')
    else:
        load_data(carton, results_model)

    if not keep:
        log.debug(f'({carton.name}): dropping intermediate table {carton.table_name!r}.')
        carton.database.drop_tables([results_model])


@click.group()
@click.option('--profile', '-p', type=str, default=None)
@click.option('--dbname', '-d', type=str, default=None)
@click.option('--user', '-u', type=str, default=None)
@click.option('--host', '-h', type=str, default=None)
@click.option('--port', '-P', type=int, default=None)
@click.option('--verbose', '-v', is_flag=True,
              help='outputs extra debug information')
def target_selection(profile, dbname, user, host, port, verbose):
    """Performs tasks related to target selection for SDSS-V."""

    if verbose:
        log.set_level(logging.DEBUG)

    assert connect(profile, dbname, user, host, port), 'database is not connected.'


@target_selection.command()
@click.argument('TARGETING-VERSION', type=str)
@click.option('--overwrite', is_flag=True,
              help='drop or truncate intermediate tables if they exist')
@click.option('--keep', is_flag=True,
              help='keep intermediate tables')
@click.option('--intermediate-schema', type=str, default='sandbox', show_default=True,
              help='the schema in which to create intermediate tables')
@click.option('--skip-query', is_flag=True,
              help='do not run the query, only load intermediate table if it exists')
@click.option('--tile/--no-tile', is_flag=True, default=None,
              help='whether to run the query in chunks tiling the sky')
@click.option('--no-load', is_flag=True,
              help='do not load data into targetdb.target')
@click.option('--include', '-i', type=str,
              help='comma-separated carton names to include')
@click.option('--exclude', '-e', type=str,
              help='comma-separated carton names to exclude')
@click.option('--write-table', '-w', is_flag=True,
              help='write intermediate table as a FITS file')
@click.option('--allow-errors', is_flag=True,
              help='continue processing cartons if a carton fails')
def run(targeting_version, overwrite, keep, intermediate_schema, tile, no_load,
        skip_query, include, exclude, write_table, allow_errors):
    """Runs target selection for all cartons."""

    Cartons = BaseCarton.__subclasses__()

    if exclude:
        Cartons = [Carton for Carton in Cartons if Carton.name not in exclude]

    if include:
        Cartons = [Carton for Carton in Cartons if Carton.name in include]

    # Create targeting version in targetdb.
    __, created = targetdb.Version.get_or_create(label=targeting_version)
    if created:
        log.info(f'created record in targetdb.version for {targeting_version!r}.')

    for Carton in Cartons:
        try:
            carton = Carton(targeting_version, schema=intermediate_schema)
            process_carton(carton, keep=keep, overwrite=overwrite,
                           skip_query=skip_query, no_load=no_load,
                           tile=tile, write_table=write_table)
        except Exception as ee:
            if allow_errors:
                log.error(f'found error processing carton {carton.name}: {ee}')
            else:
                raise


@target_selection.command()
@click.argument('TARGETING-VERSION', type=str)
@click.option('--tables', is_flag=True,
              help='also remove intermediate tables')
def clear(targeting_version, tables):
    """Clear all data for a target selection version."""

    if tables:
        Cartons = BaseCarton.__subclasses__()
        for Carton in Cartons:
            Carton(targeting_version).drop_table()

    # Manually remove magnitudes since the don't get removed by cascading.
    magnitudes = (targetdb.Magnitude
                  .select(targetdb.Magnitude.pk)
                  .join(targetdb.Target)
                  .join(targetdb.ProgramToTarget)
                  .join(targetdb.Version)
                  .where(targetdb.Version.label == targeting_version))

    targetdb.Magnitude.delete().where(targetdb.Magnitude.pk.in_(magnitudes)).execute()

    try:
        targetdb.Version.get(label=targeting_version).delete_instance()
    except peewee.DoesNotExist:
        pass


if __name__ == '__main__':

    target_selection()
