#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# @Author: José Sánchez-Gallego (gallegoj@uw.edu)
# @Date: 2020-02-27
# @Filename: target_selection
# @License: BSD 3-clause (http://www.opensource.org/licenses/BSD-3-Clause)

import logging

import click
import peewee

from sdssdb.peewee.sdss5db import targetdb as tdb
from sdssdb.peewee.sdss5db.catalogdb import Catalog, database

from target_selection import config, log
from target_selection.cartons import BaseCarton
from target_selection.exceptions import TargetSelectionError
from target_selection.xmatch import XMatchPlanner


def connect(profile=None, dbname=None, user=None, host=None, port=None):
    """Connects the database."""

    if profile:
        database.set_profile(profile)

    if dbname or user or host or port:
        database.connect(dbname=dbname, user=user, host=host, port=port)

    return database.connected


def _create_program_metadata(carton):

    survey = None
    category = None

    version_pk = tdb.Version.get(label=carton.version, target_selection=True)

    if (tdb.Program.select()
                   .where(tdb.Program.label == carton.name,
                          tdb.Program.version_pk == version_pk)
                   .exists()):
        return

    # Create program and associated values.
    if carton.survey:
        survey, created = tdb.Survey.get_or_create(label=carton.name)
        if created:
            log.debug(f'created survey {carton.survey!r}')

    if carton.category:
        category, created = tdb.Category.get_or_create(label=carton.category)
        if created:
            log.debug(f'created category {carton.category!r}')

    tdb.Program.create(label=carton.name, category=category,
                       survey=survey, version_pk=version_pk)
    log.debug(f'created program {carton.name!r}')


def load_data(carton, results):
    """Loads data from the temporary table into tdb."""

    has_targets = (results.select()
                   .where(results.selected == True)  # noqa
                   .exists())

    if not has_targets:
        raise ValueError(f'no targets found in intermediate table.')

    # TODO: add magnitude loading.

    n_inserted = tdb.Target.insert_from(
        Catalog.select(Catalog.catalogid,
                       Catalog.ra,
                       Catalog.dec,
                       Catalog.pmra,
                       Catalog.pmdec,
                       Catalog.parallax)
        .join(results, on=(Catalog.catalogid == results.catalogid))
        .where(~peewee.fn.EXISTS(
            tdb.Target
            .select(peewee.SQL('1'))
            .where(tdb.Target.catalogid == results.catalogid))),
        [tdb.Target.catalogid,
         tdb.Target.ra,
         tdb.Target.dec,
         tdb.Target.pmra,
         tdb.Target.pmdec,
         tdb.Target.parallax]).returning().execute()

    log.info(f'inserted {n_inserted:,} rows into targetdb.target.')

    version_pk = tdb.Version.get(label=carton.version, target_selection=True)
    program_pk = tdb.Program.get(label=carton.name, version_pk=version_pk).pk

    if carton.cadence is not None:

        cadence_pk = tdb.Cadence.get(label=carton.cadence)

        n_inserted = tdb.ProgramToTarget.insert_from(
            results.select(tdb.Target.pk,
                           cadence_pk,
                           program_pk)
            .join(tdb.Target,
                  on=(tdb.Target.catalogid == results.catalogid))
            .where(~peewee.fn.EXISTS(
                tdb.ProgramToTarget
                .select(peewee.SQL('1'))
                .join(tdb.Program)
                .where(tdb.ProgramToTarget.target_pk == tdb.Target.pk,
                       tdb.ProgramToTarget.program_pk == program_pk,
                       tdb.Program.version_pk == version_pk))),
            [tdb.ProgramToTarget.target_pk,
             tdb.ProgramToTarget.cadence_pk,
             tdb.ProgramToTarget.program_pk]).returning().execute()

    else:

        n_inserted = tdb.ProgramToTarget.insert_from(
            results.select(tdb.Target.pk,
                           tdb.Cadence.pk,
                           program_pk)
            .join(tdb.Target,
                  on=(tdb.Target.catalogid == results.catalogid))
            .switch(results)
            .join(tdb.Cadence, 'LEFT OUTER JOIN',
                  on=(tdb.Cadence.label == results.cadence))
            .where(~peewee.fn.EXISTS(
                tdb.ProgramToTarget
                .select(peewee.SQL('1'))
                .join(tdb.Program)
                .where(tdb.ProgramToTarget.target_pk == tdb.Target.pk,
                       tdb.ProgramToTarget.program_pk == program_pk,
                       tdb.Program.version_pk == version_pk))),
            [tdb.ProgramToTarget.target_pk,
             tdb.ProgramToTarget.cadence_pk,
             tdb.ProgramToTarget.program_pk]).returning().execute()

    log.info(f'inserted {n_inserted:,} rows into targetdb.program_to_target.')


def process_carton(carton, keep=False, overwrite=False, no_load=False,
                   skip_query=False, tile=None, write_table=False):
    """Processes the target selection for a carton."""

    log.header = f'({carton.name}): '

    log.info(f'running target selection for carton {carton.name!r}.')

    # Check if data has been loaded for this carton and targeting version
    has_targets = (tdb.Target
                   .select()
                   .join(tdb.ProgramToTarget)
                   .join(tdb.Program)
                   .join(tdb.Version)
                   .where(tdb.Program.label == carton.name,
                          tdb.Version.label == carton.version)
                   .first())

    if has_targets and (not skip_query and not overwrite):
        raise ValueError(f'(found existing targets for carton {carton.name!r} '
                         f'with version {carton.version!r}.')

    _create_program_metadata(carton)

    if not skip_query:

        if overwrite:
            log.info(f'dropping table {carton.table_name}.')
            carton.drop_table()
        else:
            if database.table_exists(carton.table_name, schema=carton.schema):
                raise RuntimeError(f'temporary table {carton.table_name!r} '
                                   'already exists.')

        results_model = carton.run(tile=tile)

    else:

        log.debug(f'skipping query.')
        results_model = carton.get_model_from_query()

    if write_table:
        carton.write_table()

    if no_load:
        log.debug(f'not loading data into tdb.target.')
    else:
        load_data(carton, results_model)

    if not keep:
        log.debug(f'dropping intermediate table {carton.table_name!r}.')
        database.drop_tables([results_model])


@click.group()
@click.option('--profile', '-p', type=str, default=None)
@click.option('--dbname', '-d', type=str, default=None)
@click.option('--user', '-u', type=str, default=None)
@click.option('--host', '-h', type=str, default=None)
@click.option('--port', '-P', type=int, default=None)
@click.option('--verbose', '-v', is_flag=True,
              help='outputs extra debug information')
def target_selection(profile, dbname, user, host, port, verbose):
    """Performs tasks related to target selection for SDSS-V."""

    if verbose:
        log.set_level(logging.DEBUG)

    if not connect(profile, dbname, user, host, port):
        raise TargetSelectionError('database is not connected.')


@target_selection.command()
@click.argument('TARGETING-VERSION', type=str)
@click.option('--overwrite', is_flag=True,
              help='drop intermediate tables if they exist')
@click.option('--keep', is_flag=True,
              help='keep intermediate tables after loading')
@click.option('--skip-query', is_flag=True,
              help='do not run the query, only load intermediate '
                   'table if it exists')
@click.option('--tile/--no-tile', is_flag=True, default=None,
              help='whether to run the query in chunks tiling the sky')
@click.option('--no-load', is_flag=True,
              help='do not load data into tdb.target')
@click.option('--include', '-i', type=str,
              help='comma-separated carton names to include')
@click.option('--exclude', '-e', type=str,
              help='comma-separated carton names to exclude')
@click.option('--write-table', '-w', is_flag=True,
              help='write intermediate table as a FITS file')
@click.option('--allow-errors', is_flag=True,
              help='continue processing cartons if a carton fails')
def run(targeting_version, overwrite, keep, tile, no_load,
        skip_query, include, exclude, write_table, allow_errors):
    """Runs target selection for all cartons."""

    carton_classes = {Carton.name: Carton
                      for Carton in BaseCarton.__subclasses__()}

    try:
        config_version = config[targeting_version]
    except KeyError:
        raise TargetSelectionError('cannot find configuration for version '
                                   f'{targeting_version}.')

    cartons = config_version['cartons']

    if exclude:
        cartons = [carton for carton in cartons if carton not in exclude]

    if include:
        cartons = [carton for carton in cartons if carton in include]

    # Create targeting version in tdb.
    __, created = tdb.Version.get_or_create(label=targeting_version,
                                            target_selection=True)
    if created:
        log.info(f'created record in tdb.version for {targeting_version!r}.')

    for carton_name in cartons:
        try:
            Carton = carton_classes[carton_name]
            carton = Carton(targeting_version)
            process_carton(carton, keep=keep, overwrite=overwrite,
                           skip_query=skip_query, no_load=no_load,
                           tile=tile, write_table=write_table)
        except Exception as ee:
            if allow_errors:
                log.error(f'errored processing carton {carton.name}: {ee}')
            else:
                raise

    log.header = ''


@target_selection.command()
@click.argument('TARGETING-VERSION', type=str)
@click.option('--tables', is_flag=True,
              help='also remove intermediate tables')
def clear(targeting_version, tables):
    """Clear all data for a target selection version."""

    if tables:
        Cartons = BaseCarton.__subclasses__()
        for Carton in Cartons:
            Carton(targeting_version).drop_table()
    try:
        tdb.Version.get(label=targeting_version).delete_instance()
    except peewee.DoesNotExist:
        pass


@target_selection.command()
@click.argument('XMATCH-VERSION', type=str)
@click.option('--file', type=click.Path(exists=True, dir_okay=False),
              help='the file to read. Defaults to the internal '
                   'configuration file.')
def xmatch(xmatch_version, file):
    """Runs catalogue cross-matching from a configuration file."""

    xmatch = XMatchPlanner.read(database, xmatch_version, config_file=file)
    xmatch.run()


if __name__ == '__main__':

    target_selection()
